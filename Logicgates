module all_logic_gates_gl(output ybuf,ynot,yand,yor,ynand,ynor,yxor,yxnor,input a,b); 
buf a1(ybuf,a); 
not a2(ynot,a); 
and a3(yand,a,b); 
or a4(yor,a,b); 
nand a5(ynand,a,b); 
nor a6(ynor,a,b); 
xor a7(yxor,a,b); 
xnor a8(yxnor,a,b); 
endmodule 
//test bench 
module all_logic_gates_tb; 
reg a,b; 
wire ybuf,ynot,yand,yor,ynand,ynor,yxor,yxnor; 
//all_logic_gates_gl uut (ybuf,ynot,yand,yor,ynand,ynor,yxor,yxnor,a,b); 
//all_logic_gates_df uut (ybuf,ynot,yand,yor,ynand,ynor,yxor,yxnor,a,b); 
all_logic_gates_bm uut (ybuf,ynot,yand,yor,ynand,ynor,yxor,yxnor,a,b); 
initial 
begin 
a=1'b0;b=1'b0; 
#10 
a=1'b0;b=1'b1; 
#10 
a=1'b1;b=1'b0; 
#10 
a=1'b1;b=1'b1; 
end 
initial 
#50 
$stop; 
endmodule 
//data flow model 
module all_logic_gates_df(output ybuf,ynot,yand,yor,ynand,ynor,yxor,yxnor,input a,b); 
assign ybuf=a; 
assign ynot=~a; 
assign yand=a&b; 
assign yor=a|b; 
assign ynand=~(a&b); 
assign ynor=~(a|b); 
assign yxor=(a^b); 
assign yxnor=~(a^b); 
endmodule 
//behaviour model 
module all_logic_gates_bm(output reg ybuf,ynot,yand,yor,ynand,ynor,yxor,yxnor,input a,b); 
always@(a or b) 
begin 
ybuf=a; 
ynot=~a; 
yand=a&b; 
yor=a|b; 
ynand=~(a&b); 
ynor=~(a|b); 
yxor=(a^b); 
yxnor=~(a^b); 
end 
endmodule
